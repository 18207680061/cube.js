{"componentChunkName":"component---guides-base-src-templates-post-jsx","path":"/performance-and-cost-optimization","result":{"data":{"markdownRemark":{"html":"<p>We've created our dashboard with a date filters in previous parts. In this\npart we're going to work on performance and cost optimization of our queries.</p>\n<p>Athena is great at handling large datasets, but will never give you a sub-second response, even on small datasets. As we saw previously, it leads to a wait time on dashboards and charts, especially dynamic, where users can select different date ranges or change filters.</p>\n<p>To solve that issue we'll use Cube.js external pre-aggregations. We'll still leverage Athena's power to process large datasets, but will put all aggregated data into MySQL. Cube.js manages all the process of building and maintaining the pre-aggregations, including refreshes and partitioning.</p>\n<p>The schema below shows the setup for Cube.js with Athena as main data source and MySQL for pre-aggregations.</p>\n<p>SCHEMA</p>\n<h3 id=\"connecting-to-mysql\" style=\"position:relative;\"><a href=\"#connecting-to-mysql\" aria-label=\"connecting to mysql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Connecting to MySQL</h3>\n<p>To use the external pre-aggregations feature, we need to configure Cube.js to connect to both Athena and MySQL, as well as specify which pre-aggregation we want to build externally. We've already configured the connection to Athena, so all we need to setup now is MySQL connection.</p>\n<p>First, we need to install Cube.js MySQL driver. Run the following command in the root folder of your project.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> --save @cubejs-backend/mysql-driver</code></pre></div>\n<p>Next, let's edit our <code class=\"language-text\">index.js</code> file in the root folder of the project.\nReplace its content with the following.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> CubejsServer <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@cubejs-backend/server\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> MySQLDriver <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@cubejs-backend/mysql-driver'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CubejsServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  externalDbType<span class=\"token operator\">:</span> <span class=\"token string\">'mysql'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">externalDriverFactory</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MySQLDriver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    host<span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">CUBEJS_EXT_DB_HOST</span><span class=\"token punctuation\">,</span>\n    database<span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">CUBEJS_EXT_DB_NAME</span><span class=\"token punctuation\">,</span>\n    user<span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">CUBEJS_EXT_DB_USER</span><span class=\"token punctuation\">,</span>\n    password<span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">CUBEJS_EXT_DB_PASS</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> port <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">ðŸš€ Cube.js server is listening on </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>port<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Lastly, we're going to add credentials to connect to MySQL to the <code class=\"language-text\">.env</code> file. Please note, that in order to build pre-aggregations inside MySQL, Cube.js should have write access to the <code class=\"language-text\">stb_pre_aggregations</code> schema where pre-aggregation tables will be stored.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">CUBEJS_EXT_DB_NAME</span><span class=\"token operator\">=</span>preags\n<span class=\"token assign-left variable\">CUBEJS_EXT_DB_HOST</span><span class=\"token operator\">=</span>localhost\n<span class=\"token assign-left variable\">CUBEJS_EXT_DB_USER</span><span class=\"token operator\">=</span>root\n<span class=\"token assign-left variable\">CUBEJS_EXT_DB_PASS</span><span class=\"token operator\">=</span><span class=\"token number\">12345</span></code></pre></div>\n<p>That is all we need to let Cube.js connect to MySQL. Now, we can move forward and start defining pre-aggregations insides our data schema.</p>\n<h3 id=\"defining-pre-aggregations-in-the-data-schema\" style=\"position:relative;\"><a href=\"#defining-pre-aggregations-in-the-data-schema\" aria-label=\"defining pre aggregations in the data schema permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Defining Pre-Aggregations in the Data Schema</h3>\n<p>The main idea of the pre-aggregation is to create a table with already aggregated data, which is going to be much smaller than the original table with the raw data. Querying such table is much faster that querying the raw data. Additionally, by inserting this table into external database, like MySQL, we'll be able to horizontally scale it, which is especially important in multi-tenant environments.</p>\n<p>Cube.js can create and maintain such tables. To instruct it to do that we need to\ndefine what measures and dimensions we want to pre-aggregate in the data schema.\nThe pre-aggregations are defined inside the <code class=\"language-text\">preAggregations</code> block. Let's\ndefine the first simple pre-aggregation first and then take a closer look how it\nworks.</p>\n<p>Inside the <code class=\"language-text\">Sessions</code> cube in the data schema add the following block.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">preAggregations<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  additive<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">rollup</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    measureReferences<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    timeDimensionReference<span class=\"token operator\">:</span> timestamp<span class=\"token punctuation\">,</span>\n    granularity<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">day</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    refreshKey<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      every<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">5 minutes</span><span class=\"token template-punctuation string\">`</span></span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    external<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The code above will instruct Cube.js to create the pre-aggregation called\n<code class=\"language-text\">additive</code> with two columns: <code class=\"language-text\">Sessions.count</code> and <code class=\"language-text\">Sessions.timestamp</code> with\ndaily granularity. The resulting table will look like the one below.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+-------------------------+-----------------+\n| sessions__timestamp_day | sessions__count |\n+-------------------------+-----------------+\n| 2020-01-19 16:00:00     |               2 |\n| 2020-01-20 16:00:00     |              71 |\n| 2020-01-21 16:00:00     |             699 |\n| 2020-01-22 16:00:00     |             608 |\n| 2020-01-23 16:00:00     |             374 |\n| 2020-01-24 16:00:00     |             139 |\n| 2020-01-25 16:00:00     |              86 |\n| 2020-01-26 16:00:00     |             128 |\n| 2020-01-27 16:00:00     |             143 |\n| 2020-01-28 16:00:00     |             123 |\n+-------------------------+-----------------+</code></pre></div>\n<p>Also, note that we specify <code class=\"language-text\">external: true</code> property, which tells Cube.js to load that\ntable into MySQL, instead of keeping it inside Athena.</p>\n<p>The <code class=\"language-text\">refreshKey</code> property defines how Cube.js should refresh that table. In our\ncase, the refresh strategy is quite simple, we just configure that\npre-aggregation to refresh every 5 minute. Refresh strategy can be much\ncomplicated depending on the required use case, you can <a href=\"https://cube.dev/docs/caching#pre-aggregations-refresh-strategy\">learn more about it in\nthe docs</a>.</p>\n<p>Now, with the above pre-aggregation in place, the following query will be\nexecuted against the pre-aggregated data and not raw data.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"measures\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"Sessions.count\"</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"timeDimensions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">\"dimension\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Sessions.timestamp\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">\"granularity\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"day\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You can use \"Cache\" button in the Playground to check whether the query uses\npre-aggregation or not.</p>\n<p><img src=\"/images/7-screenshot-1.png\"></p>\n<h3 id=\"background-scheduled-refresh\" style=\"position:relative;\"><a href=\"#background-scheduled-refresh\" aria-label=\"background scheduled refresh permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Background Scheduled Refresh</h3>\n<p>You can configure Cube.js to always keep pre-aggregations up-to-date by\nrefreshing them in the background. To enable it we need to add\n<code class=\"language-text\">scheduledRefresh: true</code> to pre-aggregation definition. Without this flag pre-aggregations are always built on-demand.</p>\n<p>Update your pre-aggregation to enable <code class=\"language-text\">scheduledRefresh</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">preAggregations: {\n<span class=\"token unchanged\">  additive: {\n    type: `rollup`,\n    measureReferences: [count],\n    timeDimensionReference: timestamp,\n    granularity: `day`,\n    refreshKey: {\n      every: `5 minutes`\n    },\n    external: true,\n</span><span class=\"token inserted-sign inserted\">+   scheduledRefresh: true\n</span><span class=\"token unchanged\">  }\n</span>}</code></pre></div>\n<p>Refresh Scheduler isn't enabled by default. We need to trigger it externally.\nThe simplest way to do that would be to make it constantly run by using <code class=\"language-text\">setInterval</code> in our\n<code class=\"language-text\">index.js</code> file.</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">const CubejsServer = require(\"@cubejs-backend/server\");\nconst MySQLDriver = require('@cubejs-backend/mysql-driver');\n\nconst server = new CubejsServer({\n<span class=\"token unchanged\">  externalDbType: 'mysql',\n  externalDriverFactory: () => new MySQLDriver({\n    host: process.env.CUBEJS_EXT_DB_HOST,\n    database: process.env.CUBEJS_EXT_DB_NAME,\n    user: process.env.CUBEJS_EXT_DB_USER,\n    password: process.env.CUBEJS_EXT_DB_PASS.toString()\n  })\n</span>});\n\n<span class=\"token inserted-sign inserted\">+ setInterval(() => server.runScheduledRefresh(), 5000);\n</span>\nserver.listen().then(({ port }) => {\n<span class=\"token unchanged\">  console.log(`ðŸš€ Cube.js server is listening on ${port}`);\n</span>});</code></pre></div>\n<p>That is the basics we need to know to start configuring pre-aggregations for our example. You\ncan inspect query by query in your dashboard and apply pre-aggregations to speed them up and also to keep your AWS Athena cost down.</p>\n<p>Congratulations on completing this guide! ðŸŽ‰</p>\n<p>You can check <a href=\"https://web-analytics-demo.cubecloudapp.dev/\">the online demo here</a> and <a href=\"https://github.com/cube-js/cube.js/tree/master/examples/web-analytics\">the source code is available on Github</a>.</p>\n<p>Iâ€™d love to hear from you about your experience following this guide. Please send any comments or feedback you might have in this <a href=\"http://slack.cube.dev/\">Slack Community</a>. Thank you and I hope you found this guide helpful!</p>","timeToRead":5,"excerpt":"We've created our dashboard with a date filters in previous parts. In this\npart we're going to work on performance and cost optimization ofâ€¦","frontmatter":{"title":"Performance and Cost Optimization"},"fields":{"slug":"/performance-and-cost-optimization"}}},"pageContext":{"config":{"siteTitle":"Building an Open Source Web Analytics Platform","siteTitleShort":"Building an Open Source Web Analytics Platform","siteTitleAlt":"Building an Open Source Web Analytics Platform","siteLogo":"/logos/icon.png","previewImage":"/logos/preview.png","siteUrl":"https://web-analytics.cube.dev","siteDescription":"Learn how to build open source web analytics platform with Cube.js.","googleAnalyticsID":"UA-70480064-3","themeColor":"#c62828","backgroundColor":"#e0e0e0","pathPrefix":"","githubUrl":"https://github.com/cube-js/cube.js/tree/master/examples/web-analytics"},"slug":"/performance-and-cost-optimization","prevtitle":"Adding Interactivity","prevslug":"/adding-interactivity","tableOfContents":[{"node":{"fields":{"slug":"/overview"},"frontmatter":{"title":"Overview","order":1}}},{"node":{"fields":{"slug":"/data-collection-and-storage"},"frontmatter":{"title":"Data Collection and Storage","order":2}}},{"node":{"fields":{"slug":"/analytics-api-with-cube-js"},"frontmatter":{"title":"Analytics API with Cube.js","order":3}}},{"node":{"fields":{"slug":"/frontend-app-with-react-and-material-ui"},"frontmatter":{"title":"Frontend App with React and Material UI","order":4}}},{"node":{"fields":{"slug":"/building-a-dashboard"},"frontmatter":{"title":"Building a Dashboard","order":5}}},{"node":{"fields":{"slug":"/adding-interactivity"},"frontmatter":{"title":"Adding Interactivity","order":6}}},{"node":{"fields":{"slug":"/performance-and-cost-optimization"},"frontmatter":{"title":"Performance and Cost Optimization","order":7}}}]}},"staticQueryHashes":[]}